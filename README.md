国际跳棋（毛哥规则版本）
=
该项目是个人项目，学生需要独立完成。学生需要使用C语言实现一个“国际跳棋”走子程序（以下称为大脑程序），使用stdin来接收对手落子情况，通过计算后使用stdout输出自己的落子（见输入输出格式）。算法不限，但有时间和内存上的限制（见比赛规则）

算法核心
-

#### 第一部分：搜索函数
&emsp;&emsp;采用了两种搜索函数，第一个是ab，第二个是pvs搜索，主变量导向搜索，是alpha-beta pruning的一个变种， ，它首先假设之前已经找到最佳估值（其值为alpha），然后应用零窗口搜索，以便快速判别此假设的正确性：如果零窗口搜索的结果是value≤alpha，那么表明之前的假设是正确的，即这步棋不会有更好的估值，程序将直接舍弃这步棋。在这种情况下，搜索时间将大大缩短。<br>
&emsp;&emsp;但是如果零窗口搜索的结果表明之前的假设是错误的，那么还需要重新进行一次常规窗口的搜索。在这种情况下，PVS算法实际上多进行了一次搜索。但由于零窗口搜索耗时相对先使用alphabeta搜索进行首层着法排序，搜索深度为5，然后再使用pvs，搜索深度为14<br>
&emsp;&emsp;若想要pvs搜索效果明显好于ab,就应该在估值函数上下功夫，在不同的情况下(如开局，最终，25-35步等等)采用不同的估值函数<br>

#### 第二部分：哈希表
&emsp;&emsp;使用哈希表来增加我搜索的速度<br>
&emsp;&emsp;第一个是实现哈希表。在棋局开始的时候，建立一个三维数组   然后，将此数组中填满随机数。若要求某一局面的哈希值，则将棋盘上所有棋子在数组 Z 中对应的随机数相加。（若要得到 32 位哈希值，数组 Z 中元素应为 32 位；要得到 64 位哈希值，数组 Z 中元素应为 64 位。）<br>
&emsp;&emsp;对要搜索的每一节点， 计算出它的一个32位哈希值（一个 32 位数对哈希表大小取模）以确定此局面在哈希表中的位置。 计算另一个64 位哈希值（ Checksum ）来校验表中的数据项是否是所要的那一项
(Zobrist 方法可以用增量式计算的方法解决，无须每次都加总所有棋子。当搜索一个新节点时只要棋子在移动前将对应的随机数从哈希值中减去，再加上该棋子在移动后对应的随机数就可以算出了该子节点的哈希值。）<br>
&emsp;&emsp;而在棋类游戏中，每步棋之间的局面变化一般不大，因此可以使用更高效的增量法来计算哈希值。 将计算哈希值的过程放进 MakeMove/UnmakeMove 的过程当中。<br>
&emsp;&emsp;计算哈希值的加减过程也可以用（ 按位）异或操作替代。<br>
